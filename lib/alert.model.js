'use strict';


/**
 * @module Alert
 * @name Alert
 * @alias Notification
 * @alias Warning
 * @description A representation of an envelope(or payload) which carries
 * disaster notifications(or warning) from source(s) to audience(s).
 *
 * A disaster alert is generated by a specific situation. The main features of an
 * alert is that it is not predictable and it is not a recurrent data. That
 * means that an alert could be an accident or a high level of pollutants
 * measure.
 *
 * @see {@link http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html}
 * @see {@link https://developers.google.com/public-alerts/reference/cap-google}
 *
 * @author lally elias <lallyelias87@gmail.com>
 * @license MIT
 * @since 0.1.0
 * @version 1.0.0
 * @public
 */


/* @todo implement alert code generator(YYYYMM-XXXX(incremented)) */
/* @todo implement alert glide number generator */
/* @todo expose CAP api source */
/* @todo consume CAP api sources */
/* @todo support multiple locales */
/* @todo support multiple locales templates */
/* @todo associated risks */
/* @todo associated incident types */
/* @todo implement alert dissemination via(sms, email etc) */


/* dependencies */
const path = require('path');
const _ = require('lodash');
const uuidv1 = require('uuid/v1');
const mongoose = require('mongoose');
const actions = require('mongoose-rest-actions');
const { env, schema } = require('@codetanzania/majifix-common');
const { Schema } = mongoose;


/* local constants */
const MODEL_NAME = env('ALERT_MODEL_NAME', 'Alert');
const { POPULATION_MAX_DEPTH, SCHEMA_OPTIONS } = schema;
const OPTION_AUTOPOPULATE = {
  select: { title: 1, source: 1, severity: 1 },
  maxDepth: POPULATION_MAX_DEPTH
};


/* alert properties */
const constants = require(path.join(__dirname, 'alert.constants'));
const {
  DIRECTION_INBOUND,
  DIRECTIONS,
  CATEGORY_OTHER,
  URGENCY_UNKNOWN,
  SEVERITY_UNKNOWN,
  CERTAINTY_UNKNOWN,
  RESPONSE_TYPE_NONE,
  STATUS_TEST,
  TYPE_ASK,
  SCOPE_PRIVATE
} = constants;


/* schemas */
const SourceSchema = require(path.join(__dirname, 'alert.source.schema'));
const EventSchema = require(path.join(__dirname, 'alert.event.schema'));
const MessageSchema = require(path.join(__dirname, 'alert.message.schema'));
const AreaSchema = require(path.join(__dirname, 'alert.area.schema'));
const ResourceSchema = require(path.join(__dirname, 'alert.resource.schema'));


/**
 * @name AlertSchema
 * @type {Schema}
 * @since 0.1.0
 * @version 1.0.0
 * @private
 */
const AlertSchema = new Schema({
  /**
   * @name source
   * @description A party(or source or authority etc) issuing alert(or warning
   * or notification)
   *
   * @type {SourceSchema}
   *
   * @author lally elias <lallyelias87@gmail.com>
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  source: SourceSchema,


  /**
   * @name event
   * @description Denoting type of the subject of the alert.
   *
   * @type {EventSchema}
   *
   * @author lally elias <lallyelias87@gmail.com>
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  event: EventSchema,


  /**
   * @name event
   * @description Denoting message of the alert.
   *
   * @type {MessageSchema}
   *
   * @author lally elias <lallyelias87@gmail.com>
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  message: MessageSchema,


  /**
   * @name area
   * @description Delineation of area(s) that may be affected by the alert.
   *
   * @type {AreaSchema}
   *
   * @author lally elias <lallyelias87@gmail.com>
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  area: AreaSchema,


  /**
   * @name resources
   * @description Additional file(s) with supplemental information related to
   * alert message e.g. an image or audio file.
   *
   * @type {ResourceSchema}
   *
   * @author lally elias <lallyelias87@gmail.com>
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  resources: [ResourceSchema],


  /**
   * @name reportedAt
   * @alias sent
   * @description Date and time the alert was issued(or generated) by the alert
   * source(or generator) e.g 2018-07-28 23:53:19 etc.
   *
   * @type {object}
   * @property {string} alias - alternative name
   * @property {object} type - schema(data) type
   * @property {boolean} required - mark required
   * @property {boolean} index - ensure database index
   * @property {object} fake - fake data generator options
   *
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  reportedAt: {
    alias: 'sent',
    type: Date,
    // required: true,
    index: true,
    fake: {
      generator: 'date',
      type: 'past'
    }
  },


  /**
   * @name expectedAt
   * @alias onset
   * @description The expected time of the beginning of the subject event of
   * the alert message e.g 2018-02-01T16:49:00
   *
   * @type {object}
   * @property {object} type - schema(data) type
   * @property {boolean} index - ensure database index
   * @property {object} fake - fake data generator options
   *
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  expectedAt: {
    type: Date,
    // required: true,
    index: true,
    fake: {
      generator: 'date',
      type: 'recent'
    }
  },


  /**
   * @name expiredAt
   * @alias expires
   * @description The expiry time of the information of the alert message
   * e.g 2018-03-03T11:19:00
   *
   * @type {object}
   * @property {object} type - schema(data) type
   * @property {boolean} index - ensure database index
   * @property {object} fake - fake data generator options
   *
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  expiredAt: {
    alias: 'expires',
    type: Date,
    // required: true,
    index: true,
    fake: {
      generator: 'date',
      type: 'future'
    }
  },


  /**
   * @name occuredAt
   * @alias effective
   * @description The effective time of the information of the alert message
   * e.g e.g 2018-02-01T15:19:00
   *
   * If not set, the effective time SHALL be assumed to be the same as
   * in <sent>.
   *
   * @type {object}
   * @property {object} type - schema(data) type
   * @property {boolean} index - ensure database index
   * @property {object} fake - fake data generator options
   *
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  occuredAt: {
    alias: 'effective',
    type: Date,
    index: true,
    fake: {
      generator: 'date',
      type: 'recent'
    }
  },


  /**
   * @name endedAt
   * @description The effective date and time when alert occurance ended
   * e.g 2018-02-01T15:19:00
   *
   * @type {object}
   * @property {object} type - schema(data) type
   * @property {boolean} index - ensure database index
   * @property {object} fake - fake data generator options
   *
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  endedAt: {
    type: Date,
    index: true,
    fake: {
      generator: 'date',
      type: 'future'
    }
  },


  /**
   * @name direction
   * @description Human readable direction(received or given) of the alert
   * i.e Inbound or Outbound.
   *
   * @type {object}
   * @property {object} type - schema(data) type
   * @property {boolean} trim - force trimming
   * @property {boolean} required - mark required
   * @property {string[]} enum - collection of allowed values
   * @property {boolean} index - ensure database index
   * @property {boolean} searchable - allow for searching
   * @property {object} fake - fake data generator options
   *
   * @since 0.1.0
   * @version 1.0.0
   * @instance
   */
  direction: {
    type: String,
    trim: true,
    enum: DIRECTIONS,
    index: true,
    searchable: true,
    fake: true
  }


}, SCHEMA_OPTIONS);


/*
 *------------------------------------------------------------------------------
 * Hook
 *------------------------------------------------------------------------------
 */


AlertSchema.pre('validate', function (next) {

  // ensure direction
  if (_.isEmpty(this.direction)) {
    this.direction = DIRECTION_INBOUND;
  }

  // normalize message address
  if (this.message && !_.isEmpty(this.message.addresses)) {
    this.addresses = [].concat(this.addresses);
  }

  // ensure reported date
  if (!this.reportedAt) {
    this.reportedAt = new Date();
  }

  // ensure event code
  if (this.event && _.isEmpty(this.event.code)) {
    //TODO refactor to use sequence generator
    this.event.code = uuidv1();
  }

  // ensure event category
  if (this.event && _.isEmpty(this.event.category)) {
    this.event.category = CATEGORY_OTHER;
  }

  // ensure event urgency
  if (this.event && _.isEmpty(this.event.urgency)) {
    this.event.urgency = URGENCY_UNKNOWN;
  }

  // ensure event severity
  if (this.event && _.isEmpty(this.event.severity)) {
    this.event.severity = SEVERITY_UNKNOWN;
  }

  // ensure event certainty
  if (this.event && _.isEmpty(this.event.certainty)) {
    this.event.certainty = CERTAINTY_UNKNOWN;
  }

  // ensure event response
  if (this.event && _.isEmpty(this.event.response)) {
    this.event.response = RESPONSE_TYPE_NONE;
  }

  // ensure message status
  if (this.message && _.isEmpty(this.message.status)) {
    this.message.status = STATUS_TEST;
  }

  // ensure message type
  if (this.message && _.isEmpty(this.message.type)) {
    this.message.type = TYPE_ASK;
  }

  // ensure message scope
  if (this.message && _.isEmpty(this.message.scope)) {
    this.message.scope = SCOPE_PRIVATE;
  }


  return next();

});


/*
 *------------------------------------------------------------------------------
 * Statics
 *------------------------------------------------------------------------------
 */


/* expose static constants */
AlertSchema.statics.MODEL_NAME = MODEL_NAME;
AlertSchema.statics.OPTION_AUTOPOPULATE = OPTION_AUTOPOPULATE;

_.forEach(constants, function assignSchemaConstant(value, key) {
  AlertSchema.statics[key] = value;
});


/*
 *------------------------------------------------------------------------------
 * Plugins
 *------------------------------------------------------------------------------
 */


/* plug mongoose rest actions*/
AlertSchema.plugin(actions);


/* export alert model */
exports = module.exports = mongoose.model(MODEL_NAME, AlertSchema);
